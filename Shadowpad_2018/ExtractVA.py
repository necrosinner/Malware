import idaapi
import idautils
import idc
import re
import string
import math



last_jmp_addr = 0
last_neg_addr = 0
last_mov_eax_addr = 0
to_Neg_arr = []
sub_addr = []

for seg_ea in Segments():
    for head in Heads(seg_ea, get_segm_end(seg_ea)):
        if ida_bytes.is_code(get_full_flags(head)):
            disasm = GetDisasm(head)
            if disasm.find('mov') != -1 and disasm.find('eax') != -1:
                last_mov_eax_addr = head
            if disasm.find('neg') != -1 and disasm.find('eax') != -1:
                last_neg_addr = head
            if disasm.find('jmp') != -1 and disasm.find('eax') != -1:
                last_jmp_addr = head
                if(idc.get_operand_value(last_mov_eax_addr,1) < 0x80000000):
                    continue
                print("\n\n===================JMP_FOUND===================")
                print("\t" + str(hex(last_mov_eax_addr))+ "\t" + GetDisasm(last_mov_eax_addr))
                print("\t" + str(hex(last_neg_addr))+ "\t" + GetDisasm(last_neg_addr))
                print("\t" + str(hex(last_jmp_addr))+ "\t" + GetDisasm(last_jmp_addr))
                print(hex(idc.get_operand_value(last_mov_eax_addr,1)))
                to_Neg_arr.append(hex(idc.get_operand_value(last_mov_eax_addr,1)))
                sub_addr.append(last_mov_eax_addr)
print(to_Neg_arr)
print(sub_addr)

def neg(value):
    return (-(value & 0x80000000) | (value & 0x7fffffff))

def revendian(string):
#Assume even number of bytes
    newstring = ''
    for i in range(math.floor(len(string)/2)):
        newstring += string[-((i+1)*2):len(string)-(2*i)]
    return newstring

for i in range(len(to_Neg_arr)):
    to_Neg_arr[i] = str(hex(neg(int(to_Neg_arr[i],16)))).replace('-','').replace("0x",'').upper()

print(to_Neg_arr)


for i in range(len(to_Neg_arr)):
    print(revendian(to_Neg_arr[i]),end='')

print("\nlength of bytes = {}".format(len(to_Neg_arr)*8))
