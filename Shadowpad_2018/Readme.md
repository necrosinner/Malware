### Hashes of the sample I analyzed
Debug.exe	A16D7C0D5CA80D16CEA88949AE0F5B4B

TosBtKbd.dll 05751EA487D99AEFEA72D96A958140D7

## Instructions for these scripts:

You must have an active session of injected Shadowpad running on a debugger, 

Dump and load all memory regions with executable code into IDA

Make code where relevant. You may need to manually edit certain areas that contain 2 jump conditions to the same address. Simply undefine code and redefine code after the E8 or E9 call using the C shortcut

You must use Scylla to correlate virtual addresses to API calls

## ExtractVA.py & Rename_Functions.py

For the sample that i had reversed, the way Shadowpad hides some of its api calls is through performing a neg operation on the api it wants to call, then patching
the binary such that instead of direct API calls, it will a subroutine which contains 
1) Mov Eax, [negative virtual address of API call]
2) Neg Eax
3) jmp Eax

we run ExtractVA.py in IDA to extract all the subroutines which contain these API calls, and also the address value of its correspondent API calls.

From here, we need to edit these these address values within any available address of our current debugging session.
We then point Scylla to this memory region to determine what api calls these virtual addresses belong to.

Then, we export Scylla's results in a xml file and drop it in the same folder as Rename_Functions.py as "data.xml"

Replace the values in Rename_Functions with the values you have found in Extract_VA.

Then, simply run the script in IDA to rename all our subroutine calls and we're done!

## Decrypt_Strings_Attempt.py

For this script, you must search for the decryption functions located in at least one memory region of Shadowpad.
From here, edit the hardcoded bytes on line 19 so that IDA can recognize this function as the decryption function.

Then, on lines 88, 91, 93,
You need to replace these constants with the constant you see in your version of shadowpad as every sample uses different constants
